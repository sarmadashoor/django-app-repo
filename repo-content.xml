<?xml version='1.0' encoding='utf-8'?>
<repository><file><path>convert_file.py</path><content>import os

def convert_to_utf8(root_dir):
    for subdir, _, files in os.walk(root_dir):
        for file in files:
            file_path = os.path.join(subdir, file)
            try:
                with open(file_path, 'r', encoding='utf-16') as f:
                    content = f.read()
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(f"Converted {file_path} to UTF-8.")
            except UnicodeError:
                print(f"Skipped {file_path} (not UTF-16).")

if __name__ == "__main__":
    root_dir = '.'  # Change this to the root directory of your project if necessary
    convert_to_utf8(root_dir)
</content></file><file><path>Dockerfile</path><content># Use an official Python runtime as a parent image
FROM python:3.9-slim

# Set the working directory inside the container
WORKDIR /django

# Copy the requirements file into the container at /django
COPY requirements.txt /django/

# Install any dependencies specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Copy the current directory contents into the container at /django
COPY . /django/

# Expose port 8000 to the outside world
EXPOSE 8000

# Run the Django server
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
</content></file><file><path>manage.py</path><content>#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
</content></file><file><path>script.py</path><content>import os
import xml.etree.ElementTree as ET

# Define the directories and file types to skip
skip_dirs = {'.git', 'venv', '__pycache__', 'cache'}
skip_files = {'.gitignore', '.gitattributes'}

# Define code file extensions and additional important file types to include
code_extensions = {
    '.py', '.js', '.html', '.css', '.java', '.c', '.cpp', '.go', '.ts', '.json', '.xml', '.yaml', '.yml',
    '.sh', '.bat', '.ini', '.conf', '.cfg', '.env', '.properties', '.sql', '.md', '.rb', '.pl', '.php'
}

# Also include certain files by name, regardless of extension
include_files = {'Dockerfile', 'Makefile', 'Vagrantfile', 'README', 'LICENSE', '.env'}

# Create the XML root
root = ET.Element("repository")

def is_code_file(file_name):
    # Check if the file has a recognized code-related extension or is in the include_files set
    return any(file_name.endswith(ext) for ext in code_extensions) or file_name in include_files

def add_to_xml_tree(parent, path, content):
    file_element = ET.SubElement(parent, "file")
    ET.SubElement(file_element, "path").text = path
    ET.SubElement(file_element, "content").text = content

def save_to_files(text_output, xml_output, base_directory):
    # Save text output
    text_file_path = os.path.join(base_directory, "repo-content.txt")
    xml_file_path = os.path.join(base_directory, "repo-content.xml")

    with open(text_file_path, 'w', encoding='utf-8') as f:
        f.write(text_output)

    # Save XML output
    tree = ET.ElementTree(xml_output)
    tree.write(xml_file_path, encoding='utf-8', xml_declaration=True)

def generate_file_tree(directory, skip_dirs, skip_files):
    file_tree = []
    for root_dir, dirs, files in os.walk(directory):
        dirs[:] = [d for d in dirs if d not in skip_dirs]  # Skip unwanted directories
        for file_name in files:
            if file_name in skip_files or not is_code_file(file_name):
                continue
            file_path = os.path.relpath(os.path.join(root_dir, file_name), directory)
            file_tree.append(file_path)
    return file_tree

def main():
    # Use the directory where the script is located as the base directory
    current_dir = os.path.dirname(os.path.abspath(__file__))
    text_output = []

    for root_dir, dirs, files in os.walk(current_dir):
        dirs[:] = [d for d in dirs if d not in skip_dirs]  # Skip unwanted directories

        for file_name in files:
            if file_name in skip_files or not is_code_file(file_name):
                continue

            file_path = os.path.relpath(os.path.join(root_dir, file_name), current_dir)
            text_output.append(f"--- {file_path} ---\n")

            with open(os.path.join(root_dir, file_name), 'r', encoding='utf-8') as f:
                content = f.read()
                text_output.append(content + "\n\n")
                add_to_xml_tree(root, file_path, content)

    # Generate the directory tree at the bottom of the file
    file_tree = generate_file_tree(current_dir, skip_dirs, skip_files)
    text_output.append("\n--- Directory Tree ---\n")
    for path in file_tree:
        text_output.append(path + "\n")

    # Save the outputs in the current directory
    save_to_files(''.join(text_output), root, current_dir)
    print(f"Output saved to {os.path.join(current_dir, 'repo-content.txt')} and {os.path.join(current_dir, 'repo-content.xml')}")

if __name__ == "__main__":
    main()
</content></file><file><path>.github\workflows\python-ci.yml</path><content>name: Python CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: 3.9

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Lint with flake8
      run: |
        pip install flake8
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

    - name: Run tests
      run: |
        python manage.py test
</content></file><file><path>apps\__init__.py</path><content /></file><file><path>apps\example_app\admin.py</path><content>from django.contrib import admin
from .models import ExampleModel

admin.site.register(ExampleModel)
</content></file><file><path>apps\example_app\apps.py</path><content>from django.apps import AppConfig

class ExampleAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.example_app'
</content></file><file><path>apps\example_app\models.py</path><content>from django.db import models

class ExampleModel(models.Model):
    name = models.CharField(max_length=100)

    def __str__(self):
        return self.name
</content></file><file><path>apps\example_app\urls.py</path><content>from django.urls import path
from .views import example_view

urlpatterns = [
    path('example/', example_view),
]
</content></file><file><path>apps\example_app\views.py</path><content>from django.http import JsonResponse

def example_view(request):
    return JsonResponse({'message': 'Hello, world!'})
</content></file><file><path>apps\example_app\__init__.py</path><content /></file><file><path>config\asgi.py</path><content>"""
ASGI config for the project.

It exposes the ASGI callable as a module-level variable named `application`.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/howto/deployment/asgi/
"""

import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
</content></file><file><path>config\settings.py</path><content>import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY', 'your-default-secret-key')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv('DEBUG', 'True') == 'True'

# Allowing hosts provided in the environment variable or using defaults
ALLOWED_HOSTS = os.getenv('ALLOWED_HOSTS', 'localhost,127.0.0.1,[::1]').split(',')

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'apps.example_app',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database configuration using environment variables
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('POSTGRES_DB', 'default_db_name'),
        'USER': os.getenv('POSTGRES_USER', 'default_user'),
        'PASSWORD': os.getenv('POSTGRES_PASSWORD', 'default_password'),
        'HOST': os.getenv('POSTGRES_HOST', 'localhost'),
        'PORT': os.getenv('POSTGRES_PORT', '5432'),
    },
    'mongo': {
        'ENGINE': 'djongo',
        'NAME': 'my_mongo_db',
        'ENFORCE_SCHEMA': False,
        'CLIENT': {
            'host': os.getenv('MONGO_HOST', 'localhost'),
            'port': int(os.getenv('MONGO_PORT', '27017')),
        },
    }
}

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
</content></file><file><path>config\urls.py</path><content>from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('apps.example_app.urls')),
]
</content></file><file><path>config\wsgi.py</path><content>"""
WSGI config for the project.

It exposes the WSGI callable as a module-level variable named `application`.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/howto/deployment/wsgi/
"""

import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
</content></file><file><path>config\__init__.py</path><content /></file></repository>